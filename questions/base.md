1. The OOP is Object Oriented Programming. 
The main idea of that is program consists of classes and instances of classes - objects. 
Classes could have inheritance hierachy. 

2. Principles of OOP:

- Incapsulation;
- Inheritance;
- Polymorphism;
- Abstraction;

3. MY : 
	Insapsulation is restriction for data access. The property of object must be modified/returned only through the specific setter/getter method.
  Internet : It's property of system, allows to hide details of class implementation from the user.

 4. What is the inheritance? 

Inheritance is ability of system to write new class with using properties and methods from the other one.
Inheritance classes is divded into parent and childs. 

5. What is polymorphism? 


Polymorphism is ability of system to choose specific interface implementation on runtime based on object type. 


6. What is abstraction? 

Abstraction is ability of system to highlight only valuable object characterisitcs.

Internet : 

The main idea is to decouple the way of using composite data objects from the details of their implementation in the form of simpler objects.



7. A class is a way of describing an entity, defining the state and behavior that depends on that state, as well as the rules for interacting with this entity (contract).


Object is specific instance of class which his own state and behavior.

Interface is a contract which defines behaviour.

8. Pros and cons of OOP:

Pros: 

- Ability to describe and implement the entity from real life.
- Ability to use abstractions instead of specefic realization for class implementation. 
- Ability to incapsulate data;
- Ability to use properties of another class.
- Ability to use polymorphism. 


Cons: 

- High level of abstractions;
- Neccesity for programmer to learn new oop entites and principles;
- In case of high abstraction level it's difficul to understand how code works;
- Non-effective memory distribution because of type checking and dynamic coupling;

9. What is the difference between "Has Is" and "As Is" ?


As is - inheritance.
Has is - association;

10. What is the diff between composition and aggregation? 


Composition - more restricted type of association between two entities.
So, it means that E1 fully related on E2. In case of deletion E2, E1 should be deleted too. 

Aggregation - type of relationships beetwen two entities, means that E1 is part of E2. 


11. Static and Dynamic coupling?

Static(Early) : In early binding, the method defination and the method call are linked during the compile time.

Dynamic(Late) : The major advantage of late binding is its flexibility since a single method can handle different type of objects at run time.

12. JVM:

https://www.javainterviewpoint.com/wp-content/uploads/2016/01/JVM-Architecture.png

JVM is divided into 3 subsystems:

1) Classloader Sybsystem
2) Runetime Data Area
3) Execution Engine


Classloader subsystem :
1) Loading
    BootStrap ClassLoader – Responsible for loading classes from the bootstrap classpath, nothing but rt.jar. Highest priority will be given to this loader.
    Extension ClassLoader – Responsible for loading classes which are inside the ext folder (jre\lib).
    Application ClassLoader – Responsible for loading Application Level Classpath, path mentioned Environment Variable, etc.

2) Linking
	
    Verify – Bytecode verifier will verify whether the generated bytecode is proper or not if verification fails we will get the verification error.
    Prepare – For all static variables memory will be allocated and assigned with default values.
    Resolve – All symbolic memory references are replaced with the original references from Method Area.

3) Initialization

	This is the final phase of ClassLoading; here, all static variables will be assigned with the original values, and the static block will be executed.

Runtime data area: 

    1) Method Area – All the class-level data will be stored here, including static variables. There is only one method area per JVM, and it is a shared resource.
    2) Heap Area – All the Objects and their corresponding instance variables and arrays will be stored here. There is also one Heap Area per JVM. Since the Method and Heap areas share memory for multiple threads, the data stored is not thread-safe.
    3) Stack Area – For every thread, a separate runtime stack will be created. For every method call, one entry will be made in the stack memory which is called Stack Frame. All local variables will be created in the stack memory. The stack area is thread-safe since it is not a shared resource. The Stack Frame is divided into three subentities:
        3.1) Local Variable Array – Related to the method how many local variables are involved and the corresponding values will be stored here.
        3.2) Operand stack – If any intermediate operation is required to perform, operand stack acts as runtime workspace to perform the operation.
        3.3) Frame data – All symbols corresponding to the method is stored here. In the case of any exception, the catch block information will be maintained in the frame data.
    4) PC Registers – Each thread will have separate PC Registers, to hold the address of current executing instruction once the instruction is executed the PC register will be updated with the next instruction.
    5) Native Method stacks – Native Method Stack holds native method information. For every thread, a separate native method stack will be created.


Execution Engine: 

    1) Interpreter – The interpreter interprets the bytecode faster but executes slowly. The disadvantage of the interpreter is that when one method is calleed multiple times, every time a new interpretation is required.

    2) JIT Compiler – The JIT Compiler neutralizes the disadvantage of the interpreter. The Execution Engine will be using the help of the interpreter in converting byte code, but when it finds repeated code it uses the JIT compiler, which compiles the entire bytecode and changes it to native code. This native code will be used directly for repeated method calls, which improve the performance of the system.
        Intermdiate Code Generator – Produces intermediate code
        Code Optimizer – Responsible for optimizing the intermediate code generated above
        Target Code Generator – Responsible for Generating Machine Code or Native Code
        Profiler – A special component, responsible for finding hotspots, i.e. whether the method is called multiple times or not.
    
    3) Garbage Collector: Collects and removes unreferenced objects. Garbage Collection can be triggered by calling System.gc(), but the execution is not guaranteed. Garbage collection of the JVM collects the objects that are created.

	4) Java Native Interface (JNI): JNI will be interacting with the Native Method Libraries and provides the Native Libraries required for the Execution Engine.

	5) Native Method Libraries: This is a collection of the Native Libraries, which is required for the Execution Engine.

Another source: 

1) JVM architecture
	
	1.0  Classloaders
    1.1. The pc Registers - PC register store the address of the Java virtual machine instruction which is currently executing. In Java, each thread has its separate PC register.
    1.2. Java Virtual Machine Stacks
    1.3. Heap
    1.4. Method Area - JVM Method Area stores class structures like metadata, the constant runtime pool, and the code for methods. 
    1.5. Run-Time Constant Pool
    1.6. Native Method Stacks - Native method stacks hold the instruction of native code depends on the native library. It is written in another language instead of Java. 
    1.7. Execution engine
    1.8. Native Method Interface - The Native Method Interface is a programming framework. It allows Java code which is running in a JVM to call by libraries and native applications. 
    1.9. Native Method Libraries - Native Libraries is a collection of the Native Libraries(C, C++) which are needed by the Execution Engine. 


Concurrency:


1. Whate is JMM? 

JMM describes behavior of threads in java. Piece of Java semantics, 
JMM is set of rules which define how code executes in multithreaded environment
and rules which defines how threads will communicate to each other on the common memory.

Some rules of happens before relation:

1) In one thread any operation HP any other operation which following her in source code.
2) Monitor unlock happens vefore this monitor lock.

Attributes of JMM:

1) Happens before : 

If process X hp Y than each processor instructions which is going after Y will see the changes of X in the same thread.

2) Ordering : 

It means that processor can change the order of code execution for optimization. 

3) Visibility : 

Data can be stored in locale and global memory. Local is processor cache, registers. 

2. What is thread safety?

Gurantee that code executed in mulithreaded maneer will work as in sequntial.

3. What is the diff between concurrency and parallelism?


Concurrency means execution of code in the multithreaded env.

Parallelism is aboout tasks decomposition.


5. What are ordering, as-if-serial semantincs, sequntial consistency, visiblility, atomicity, happens before, mutual exclusion, safe publication?

Ordering :

Processor can change the order of instruction execution. So, if thread B is watching on thread A, it can see not expected execution order as sequential. 


Sequntial consistency :


The result of code in multithreaded environment should be same as in single thread. 


Visiblility :

???

Atomicity : 

Code can be executed or not. Thread safe non-blocking operation.


Happens before :

???

Mutual exclusion: 

Relates to existing thread safe techniques like Semaphore, CountDownLatch and etc.


6. What is the diff betweem thead and process? 

Process has own memory address. Process consists of threads. 

7. How to create Thread?

-Runnable
-Callable
to ExecutorService
- new Thread.

8. What is diff between Thread and Runnanble? 

Thread is class, Runnable - interface.
Runnable allows to separate thread logic from the execution.
Allows multi inheritance.


9. What is green threads? 

Virtual JVM threads which are not associated with OS threads. Like coroutines.


10. Start() begin the thread execution instead of run.
Run is thread body. 

11. What is synchronization? 

Synchronization - guaranteed thread-safe code execution in a multithreaded environment.


12. Ways for sync?

- Intrinsic locks;
- Synchronized key word on object, method, static method;
- Mutual exlusion techniquees;
- Atomicity;


13. States of thread:

1. New
2. Running
3. Waiting
4. Blocked
5. Timed waiting
6. Terminated


14. What is monitor in Java?

Monitor or mutex is processor instructions which limits access to resource.

15. Можно ли создавать новые экземпляры класса, пока выполняется static synchronized метод?

Yes, since syncronized static blocks only statis members of class.

16. Зачем может быть нужен private мьютекс?

???

17. Как работают методы wait() и notify()/notifyAll()?

 - wait() : takes off monitor from object and switches to waiting.
 - notify() : wakes up thread and switches his states from the waiting to runnable.
 - notify() : wakes up all threads associated with object.

 18. Почему методы wait() и notify() вызываются только в синхронизированном блоке?

- ???

19. Чем отличается работа метода wait() с параметром и без параметра?

Wait with argument swtiches thread state of object to timed_waiting. It's not neccessary to execute notify for waking up.

20. Чем отличаются методы Thread.sleep() и Thread.yield()?

Thread.sleep() - switch thread to timed_wating state.
Thread.yield() - delegate process time to another thread.


21. Как работает метод Thread.join()?

Holds main thread till current thread will be executed.

22. Что такое deadlock?

One type of Liveness problems. 
It's a situation when two threads hold block and trying to get access to the blocked object of each other.

23. Что такое livelock?

Another kind of liveness problem.
So, if thread acts in response to the action of another thread. And this thread also acts in response of the first thread, so we can have livelock. The diff between deadlock and livelock is threads are not blocked but they unable to make furher progress. 

24. Как проверить, удерживает ли поток монитор определённого ресурса?

???? 


25. На каком объекте происходит синхронизация при вызове static synchronized метода?


The syncroonization acts on whole class and it static members.

26. Для чего используется ключевое слово volatile, synchronized, transient, native?

- volatile manage visibility of variable or whole object in processor memory.
- synchronized key word for taking blocking synchronization
- transient makes field not serializable
- native key word from the another world.

27. В чём различия между volatile и Atomic переменными?

volatile does not gurantee that field value will be consistent in multithreaded env.

28. What is FutureTask?

Asyncronous cancelable task. Implements RunnableFuture interface.

29. В чем заключаются различия между CyclicBarrier и CountDownLatch?
???

30. Что такое race condition?

When two threads are started we will access object in random order.

31. Существует ли способ решения проблемы race condition?

- blocking, non-blocking syncronization. 

32. Как остановить поток?

interrupt()

33.Почему не рекомендуется использовать метод Thread.stop()?

Can leads to dead lock.

34. Что происходит, когда в потоке выбрасывается исключение?

If exception is not handled thread will be terminated.

35. Что такое «пул потоков»?

ThreadPool is predefined pool of thread with specific size. 
Initializes on compilation phase. 
Solve performance issue of thread creation. 

36. Какого размера должен быть пул потоков?

Should be equals to number of cores of processors.

37. Что будет, если очередь пула потоков уже заполнена, но подаётся новая задача?
 
It depends on 

38. В чём заключается различие между методами submit() и execute() у пула потоков?

submit returns Future.
execute is void method.

39. В чем заключаются различия между cтеком (stack) и кучей (heap) с точки зрения многопоточности?

Stack has it's own thread.
Heap is common shared resource. 

40. Как поделиться данными между двумя потоками?

Producer - Consumer pattern
BlockingQueue

41. Какой параметр запуска JVM используется для контроля размера стека потока?
-XSS

42. Как получить дамп потока?
???

43. Что такое ThreadLocal-переменная?
???

44. Назовите различия между synchronized и ReentrantLock?

-

45. Что такое ReadWriteLock?


46. Что такое ThreadLocal-переменная?


ThreadLocal is variable which holds state of object in thread local table.
Key is thread local, value object.

47. Назовите различия между synchronized и ReentrantLock?

ReentrantLock allows to check if blocking can be taked. And skip blocking if its busy.
Both work on mutex.


48. Что такое ReadWriteLock?


Another kind of intrisic lock. 
Blocks read write operations on object.

49. Что такое «блокирующий метод»?

method which have synchornized word in definition 

50. Что такое «фреймворк Fork/Join»?

Working by stealing alghoritm.
If current thread does not have a task it will steal from the thread in queue.

Forks tasks, executes and join. 

51. Semaphore 

Mutual exlucsion thenciquee of getting synchronization on object.

52. Что такое double checked locking Singleton?


if two threads are trying to get access to the same resorcr like getInstance of Singleton class, 
it can be initiazed few times.

53. Как создать потокобезопасный Singleton?

As for me more preferable through internal statis class.

54. Чем полезны неизменяемые объекты?

Does not change their state during execution. 

55. Busy spin?
???

56. Перечислите принципы, которым вы следуете в многопоточном программировании?
	???

57. Что происходит, когда в потоке выбрасывается исключение?

Thread.UncaughtExceptionHandler 

Fork/Join Pool:

if (my portion of the work is small enough)
  do the work directly
else
  split my work into two pieces
  invoke the two pieces and wait for the results

  
58. SOLID:

58.1 Single Responsibility Proncople:

One class should be responsible only for one user or actor.

If a class is responsible for solving several problems, 
its subsystems that implement the solution of these problems turn out to be connected with each other. 
Changes in one such subsystem lead to changes in another. 


Ex. Class for calculating finance report


58.2 Open Close Principle: 

The program should be opened for extension and closed for modification. 

Ex. ???


58.3 Liskov Substitution Principle: 

So. In 1988 Barbar Liskov suggested principle that tells, 

If we have object o1 with type T and object o2 with type S
and program P. So, if behaviour of P is not changed after replacing o1 to o2 than S is subtype of T.


58.4 Interface Segregation Principle:

To have more correct architecture with minimizing potential issues, 
we have to divide classes by their specific interfaces and use only neccessary.

Ex:


58.5  Dependency Invesrion Principle. 

We have to define dependencies that depend on abstractions but Not specific implementations






What was you major challenge during last year?

For the last, the major challenge for me was work with students in scope of ArtGallery project. 
So, since I've been as team lead and mentor in parallel it means that I had to
deliver project on time and educate students to close their basic knowledge and practical experience gaps.

I had to 
- delegate and pritorize tasks;
- sometimes it was needed to motivate peoples too.


Also, I had to combine ArtGallery with my production project.
    
What is your regular day, how do you manage your tasks/time?
    

At the beggining of the day, I'm checking 
my emails, 
nightly builds result, 
current scheduling of meetings, 
the result of CI merge jobs. 


So, I prefer to follow basic time management rules like:

- build to-do list for the future period;
- priotorize tasks based on their importance and urgent;
- focus on high priority tasks, or tasks from the previous day/period;
- sometimes, to achieve more efficiency of work I had to to say no to some person;


Difference between assignment and delegation. Are there tasks you can't delegate.
    
Delegation is transfer obligations or responsiblities to another contractor, assignment is not. 

What estimation techniques do you know? How do you estimate unknown tasks?

-Estimation by Analogy;
- Bottom-up Estimates;
Divide tasks to sbutasks. 
- Three-Point Estimate;
Optimistic, Realistic, Pessimistic;
- Parametric Estimating;
- Use Case Points
- Planning pocker;

I'll provide proughly estimation.

What bottlenecks you've optimized? How did you measure performance afterwards?
    
Yourkit profiler. Situation with architecture gap.
3
Customer complains that page opens slowly. How would you approach this?

Firstly, we neee to classify issue, is it specific envrionment or application related. 
Secondly, identify where slowness is performed front-end, back-end
Thirdly, check logs, run profilers, find queries related to this workflow.

Compare maven and gradle. Advantages and disadvantages.
    
upsa profile

postgres vs oracle vs mssql vs mysql 


How would you ensure there are no new issues when you perform refactoring of legacy code?
    
run unit tests.

Compare REST and SOAP.
 									SOAP 	REST
Meaning 	Simple Object Access Protocol 	Representational State Transfer

Design 	Standardized protocol with pre-defined rules to follow. 	Architectural style with loose guidelines and recommendations.

Approach 	Function-driven (data available as services, e.g.: “getUser”) 	Data-driven (data available as resources, e.g. “user”).


Statefulness 	Stateless by default, but it’s possible to make a SOAP API stateful. 	Stateless (no server-side sessions).

Caching 	API calls cannot be cached. 	API calls can be cached.

Security 	WS-Security with SSL support. Built-in ACID compliance. 	Supports HTTPS and SSL.

Performance 	Requires more bandwidth and computing power. 	Requires fewer resources.

Message format 	Only XML. 	Plain text, HTML, XML, JSON, YAML, and others.

Transfer protocol(s) 	HTTP, SMTP, UDP, and others. 	Only HTTP

Recommended for 	Enterprise apps, high-security apps, distributed environment, financial services, payment gateways, telecommunication services. 	Public APIs for web services, mobile services, social networks.

How did you approach application design for academy? What diagrams do you use when document your project behavior? In what order?
    

Advantages 	High security, standardized, extensibility. 	Scalability, better performance, browser-friendliness, flexibility.

Disadvantages 	Poorer performance, more complexity, less flexibility. 	Less security, not suitable for distributed environments.  

- Some diagrams were provided by myself, but some from the students side. 
I have designed component diagram, deployment diagram, sequence diagram of basic flow in application.

Compare in-memory and distributed cache in distributed environments?
    
consitency, relaibility.

How would you ensure quality on your project?
    
What are the characteristics of a high-quality Unit test?
    
How do you find a balance between different types of tests on your project?
    
How CI/CD pipeline on your project looks like? Is there anything you want to improve?
    
compare spring boot to spring
    
How would you convince customer that you need to spend some sprints on refactoring?
    
What if customer asks you include something unplanned in the middle of the sprint?
    
What would you do, if some important story takes more time that was planned due to some developer mistakes and you cannot deliver it this sprint.
    
If you have interesting task and two developers who both want to implement it, how will you decide who you assign it?
    
How will you onboard junior on your project? How will you understand everything is going well?
    
Could  you name some NFR that you should enforce on your project?


Kafka

 High-throughput
 Low Latency
 Fault-Tolerant
 Durability
 Scalability

Delivery semantics:

At most once:
 - Message pulled once;
 - Receipt not guranteed;
 - Message can be lost;
 - No duplicates;
 - Fast;

At least once:
 - Message pulled one or more times; Processed each time
 - Receipt guaranteed;
 - Message are never lost;
 - Likely duplicates;
 - Medium;

Exactly once:
 - Message pulled one or more times;
 - Receipt guranteed;
 - Message are never lost;
 - No duplicates;
 - Slow;


					Kafka 			VS 		RabbitMQ


Message Order 		Supports in 			Not Supported
					partitions


Message Lifetime    Since kafka is 			Since RabbitMQ is Queue,
					a log system			not supported
					it supports 
					message stroing
					based on retention 
					policy.


Delivery Guarantees Kafka guarantees 		Doesnt'
					that the whole batch 
					of messages either 
					fails or passes.  	


Message Priorities	No 						Guarantee





REST

Restful principles:

1. Client-server
2. Stateless
3. Cacheable
4. Uniform interface
	REST is defined by four interface constraints: 
		- identification of resources; 
		- manipulation of resources through representations; 
		- self-descriptive messages; 
		- and, hypermedia as the engine of application state.
5. Layered system
6. Code on demand



Rest best-practicies:

1. Accept and respond with JSON
2. Use nouns instead of verbs in endpoint paths
3. Name collections with plural nouns
4. Nesting resources for hierarchical objects
5. Handle errors gracefully and return standard error codes
6. Allow filtering, sorting, and pagination
7. Maintain Good Security Practices
8. Cache data to improve performance
9. Versioning our APIs



Первая нормальная форма (1NF) — нет повторяющихся групп в строках
Вторая нормальная форма (2NF) — каждое неключевое (поддерживающее) значение столбца зависит от всего первичного ключа
Третья нормальная форма (3NF) — каждое неключевое значение зависит только от первичного ключа и не имеет зависимости от другого неключевого значения столбца

  					dirty reads 	non-repeatable reads 	phantom reads
READ_UNCOMMITTED 	 	yes							yes 	yes
READ_COMMITTED 		 	no							yes 	yes
REPEATABLE_READ 	 	no							no 		yes
SERIALIZABLE 		 	no							no 		no


The CAP theorem states that a distributed computer system cannot guarantee all of the following three properties at the same time:

    Consistency
    Availability
    Partition tolerance


A BASE system gives up on consistency.

Basically available indicates that the system does guarantee availability, in terms of the CAP theorem.

Soft state indicates that the state of the system may change over time, even without input. This is because of the eventual consistency model.

Eventual consistency indicates that the system will become consistent over time, given that the system doesn't receive input during that time.

Nonfunctional Requirements (NFRs) define system attributes such as 
security 
reliability 
performance 
maintainability 
scalability
and usability
